
---
title: '操作系统是如何启动起来的？'
categories: 
 - 新媒体
 - ZAKER
 - channel
headimg: 'https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202202/62174aad8e9f097d4c222355_1024.jpg'
author: ZAKER
comments: false
date: Thu, 24 Feb 2022 02:50:00 GMT
thumbnail: 'https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202202/62174aad8e9f097d4c222355_1024.jpg'
---

<div>   
<p></p><div class="img_box" id="id_imagebox_0" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_0" data-original="http://zkres2.myzaker.com/202202/62174aad8e9f097d4c222355_1024.jpg" data-height="627" data-width="940" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202202/62174aad8e9f097d4c222355_1024.jpg" referrerpolicy="no-referrer"></div></div>出品 | 码农的荒岛求生<p></p><p>操作系统被称为 " 第一个程序 "，the first programme，原因很简单，只有当操作系统启动起来后才能运行我们编写的程序，那么你有没有想过这个问题：操作系统是怎样启动起来的呢？<strong>实际上这个过程就像发射火箭一样有趣</strong>，看完这篇你就明白啦。</p><p></p><div class="img_box" id="id_imagebox_1" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_1" data-original="http://zkres1.myzaker.com/202202/62174aad8e9f097d4c222356_1024.jpg" data-height="828" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres1.myzaker.com/202202/62174aad8e9f097d4c222356_1024.jpg" referrerpolicy="no-referrer"></div></div><strong>操作系统也是普通程序</strong><p></p><p>首先我们必须意识到这样两点：</p><p>CPU 执行的是机器指令，编译器将程序翻译后成了机器指令</p><p>操作系统本身也是一个程序，这个程序被编译后也会生成一大堆机器指令</p><p>现在我们知道了，操作系统本身其实也是一大堆机器指令，既然是机器指令那么它必须得存放在什么地方。</p><p>存放在哪里呢？</p><p>想想我们编写的程序，编译后生成的是可执行文件，也就是说是以 " 文件 " 的形式存放的，并且存放在硬盘上，而操作系统也没什么不同，编译后生成的机器指令同样是以文件的形式存放的，存放在哪里呢？可以存放在任何能存储数据的介质，像 CD、磁盘之类都可以。</p><p></p><div class="img_box" id="id_imagebox_2" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_2" data-original="http://zkres2.myzaker.com/202202/62174aad8e9f097d4c222357_1024.jpg" data-height="285" data-width="956" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202202/62174aad8e9f097d4c222357_1024.jpg" referrerpolicy="no-referrer"></div></div>我们编写的程序在启动时被加载器——也就是 loader，加载到内存，加载器也是一个程序，这是一个加载其它程序的程序；这么说可能有点拗口，但计算机系统中有大量类似的程序，编译器是一个翻译程序的程序、操作系统是一个运行其它程序的程序、链接器是一个链接程序的程序、解释器是一个执行脚本程序的程序等等。<p></p><p><strong>鸡生蛋蛋生鸡的问题</strong></p><p>回到我们的主题，我们写的代码是 loader 加载到内存后运行的，那么操作系统这个程序是也同样的道理，必须得有个什么东西也要把操作系统加载到内存中运行才可以，这个东西不叫 loader，而是叫 boot loader，其本身也是一个程序，<strong>它的任务就是加载一个更大的程序</strong>，就像这里的操作系统。</p><p></p><div class="img_box" id="id_imagebox_3" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_3" data-original="http://zkres2.myzaker.com/202202/62174aad8e9f097d4c222358_1024.jpg" data-height="459" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202202/62174aad8e9f097d4c222358_1024.jpg" referrerpolicy="no-referrer"></div></div>此时这里会出现一个鸡生蛋蛋生鸡的，既然我们的程序是被加载器 loader ( 操作系统的一部分 ) 加载到内存中，而操作系统又是被 boot loader 这个加载程序加载到内存中的，那么又是什么加载器把 boot loader 这个加载程序加载到内存中呢？而又又是什么加载器把上一句中的什么加载器加载内存中呢？而又又又是什么。。？<p></p><p></p><div class="img_box" id="id_imagebox_4" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_4" data-original="http://zkres1.myzaker.com/202202/62174aad8e9f097d4c222359_1024.jpg" data-height="332" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres1.myzaker.com/202202/62174aad8e9f097d4c222359_1024.jpg" referrerpolicy="no-referrer"></div></div>你会发现这个一个没有出口的无穷递归啊有没有，总得有个什么把前一个程序加载到内存，<strong>就好比今天的前一天是昨天、昨天的前一天是前天、前天的前一天是大前天，如果一直这样思考下去那么时间到底在哪里开始的呢</strong>？时间到底有没有开始 ( 参考时间简史或相对论 ) ？<p></p><p>时间有没有开始这个问题我不清楚，但操作系统启动的这个问题我知道。</p><p>上述关于加载器以及加载加载器等问题全部指向了内存，让我们好好想一想内存有什么特殊性？</p><p><strong>内存断电后是无法保存数据</strong></p><p>程序员都知道内存只有在加电的情况下才可以保存数据 ( 关于内存的实现原理你可以参考这篇《你管这破玩意叫 CPU？》 ) ，那么很显然，<strong>当断电后内存中的内容就丢失了</strong>，那么又很显然的，当你在按下计算机开关通电时，内存中的内容是未被初始化的，也就是说内存中的内容是无效的，<strong>此时的内存里还是一片荒芜</strong>，这里没有任何东西可供 CPU 来执行，这就好比大爆炸之前的宇宙。</p><p></p><div class="img_box" id="id_imagebox_5" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_5" data-original="http://zkres1.myzaker.com/202202/62174aad8e9f097d4c22235a_1024.jpg" data-height="504" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres1.myzaker.com/202202/62174aad8e9f097d4c22235a_1024.jpg" referrerpolicy="no-referrer"></div></div>但我们的计算机总是能启动起来，CPU 必须得执行 " 一段什么程序 " 把第一个 boot loader 加载到内存中，<strong>由于此时内存中还什么都没有，那么这段程序一定被保存在了其它地方</strong>。<p></p><p>保存在了哪里呢？</p><p>没错，这段程序就被保存在了 BIOS 的非易失性存储 ROM 或者 flash 存储中了，这里的代码在即使断电后也会保存下来，加电后 CPU 开始执行这里代码，把 boot loader 加载到内存中，现在你应该明白第一个 boot loader 是怎样被加载到内存的了吧。</p><p></p><div class="img_box" id="id_imagebox_6" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_6" data-original="http://zkres1.myzaker.com/202202/62174aad8e9f097d4c22235b_1024.jpg" data-height="455" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres1.myzaker.com/202202/62174aad8e9f097d4c22235b_1024.jpg" referrerpolicy="no-referrer"></div></div>在早期的计算机上甚至专门有一个按钮，让用户自己选择该从哪里，比如打孔纸带、打孔卡片或者硬盘，加载一个更复杂的程序来运行，操作面板上的旋钮可以控制把这些程序加载到内存的什么位置上去：<p></p><p></p><div class="img_box" id="id_imagebox_7" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_7" data-original="http://zkres1.myzaker.com/202202/62174aad8e9f097d4c22235c_1024.jpg" data-height="540" data-width="800" src="https://cors.zfour.workers.dev/?http://zkres1.myzaker.com/202202/62174aad8e9f097d4c22235c_1024.jpg" referrerpolicy="no-referrer"></div></div><strong>火箭与操作系统启动</strong><p></p><p>然而现实情况比较复杂，我们刚才提到的 boot loader 这段小程序功能实在是太弱了，此时其能访问的磁盘地址空间有限，不能把完整的内核全部加载到操作系统中，该怎么办呢？</p><p>既然 boot loader 比较弱那么就换一个比较牛的 loader 程序来，就这样出现了二阶 boot loader，second stage loader：</p><p></p><div class="img_box" id="id_imagebox_8" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_8" data-original="http://zkres1.myzaker.com/202202/62174aad8e9f097d4c22235d_1024.jpg" data-height="431" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres1.myzaker.com/202202/62174aad8e9f097d4c22235d_1024.jpg" referrerpolicy="no-referrer"></div></div>二阶 boot loader 功能更为丰富，比如对硬件进行检查、给用户提供选项加载哪个操作系统等等，安装多系统的同学应该知道，启动时会给你一个选项到底是启动 windows 还是 linux，这就是二阶 boot loader 的作用。<p></p><p></p><div class="img_box" id="id_imagebox_9" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_9" data-original="http://zkres1.myzaker.com/202202/62174aad8e9f097d4c22235e_1024.jpg" data-height="513" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres1.myzaker.com/202202/62174aad8e9f097d4c22235e_1024.jpg" referrerpolicy="no-referrer"></div></div>最终，操作系统被二阶 boot loader 加载到内存中开始运行。<p></p><p>你会发现这个过程就和发射三级火箭一样，最初一级火箭启动，燃料用尽后二级火箭启动，二级火箭完成使命后三级火箭启动，最终把卫星送到太空，而计算机的启动过程也类似。</p><p>最初是 CPU 运行 BIOS 中的一段代码把一级 boot loader 加载到内存中运行，该程序又会把二级 boot loader 加载到内存运行，而二级 boot loader 又会把操作系统加载到内存中，此后控制权被转移到操作系统， ( 所谓控制权是指 CPU 跳转到操作系统的代码 ) ，操作系统开始运行，经过一系列的初始化，比如硬件检测、开启必要的后台进程等等，最终图形界面或者命令行界面呈现出来。</p><p></p><div class="img_box" id="id_imagebox_10" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_10" data-original="http://zkres1.myzaker.com/202202/62174aad8e9f097d4c22235f_1024.jpg" data-height="527" data-width="940" src="https://cors.zfour.workers.dev/?http://zkres1.myzaker.com/202202/62174aad8e9f097d4c22235f_1024.jpg" referrerpolicy="no-referrer"></div></div>接下来我们把这个过程细化一下。<p></p><p><strong>更详细的启动过程</strong></p><p>你在按下电源的瞬间相当于火箭点火，此时一级发动机开始工作。</p><p>加电 CPU 重置后开始在地址 0xffff0 处开始执行指令，这个地址其实是 BIOS ROM 的末尾处，该位置其实是一个跳转指令，跳转到 ROM 的一段启动代码上，该代码会进行必要的自检，Power-on self-test ( POST ) ，展示 BIOS 启动界面等等，最重要的一步是找到启动设备，所谓启动设备就是指从哪里加载操作系统，比如 CD-ROM、或者磁盘、甚至 U 盘等都可以作为启动设备，早些年流行用 U 盘重新安装系统，其实就是告诉 BIOS 的这段代码从 U 盘中加载操作系统。</p><p>通常 BIOS 会把磁盘当做启动设备 ( 大部分情况下 ) ，此时 BIOS 中的这段代码开始将磁盘的第 0 号块加载到内存中，那么这第 0 号块中有什么呢？没错，就是第一阶段 boot loader 程序，这第 0 号块也被称之为 Master Boot Record，MBR，肯定有不少同学听说过。</p><p></p><div class="img_box" id="id_imagebox_11" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_11" data-original="http://zkres2.myzaker.com/202202/62174aad8e9f097d4c222360_1024.jpg" data-height="488" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres2.myzaker.com/202202/62174aad8e9f097d4c222360_1024.jpg" referrerpolicy="no-referrer"></div></div>到这里，火箭的一级发动机燃料用尽，二级发动机开始点火，BIOS 中的这段代码把控制权交给加载到内存 boot loader，所谓控制权就是跳转到 boot loader 程序，这样 CPU 终于开始直接与内存交互了，CPU 开始从内存中取出指令然后执行。<p></p><p>MBR 中除了包含一段可执行代码之外还有一个分区表，partition table，这个表的中的每一个条目本质上在说：" 操作系统是否在我这个分区，我这个分区有多大 "，CPU 在执行 MBR 中的代码时会去检查操作系统存在哪个分区中，定位后开始从相应分区的起始位置读取磁盘数据到内存中，这时的磁盘数据中保存的就是二阶 boot loader，second-stage boot loader，此时一阶 boot loader 把控制权转交给二阶 boot loader，火箭三级发动机开始工作。</p><p>2_boot loader 的主要工作将操作系统加载到内存中，此后控制权转交给操作系统，火箭的三级发动机完成使命，<strong>到这一时刻，操作系统开始接管计算机</strong>，操作系统经过一系列自身的初始化后创建出若干必要进程，至此计算机启动完毕，卫星被成功送到了外太空中。</p><p></p><div class="img_box" id="id_imagebox_12" onclick><div class="content_img_div perview_img_div"><img class="lazy opacity_0 " id="img_12" data-original="http://zkres1.myzaker.com/202202/62174aad8e9f097d4c222361_1024.jpg" data-height="474" data-width="1080" src="https://cors.zfour.workers.dev/?http://zkres1.myzaker.com/202202/62174aad8e9f097d4c222361_1024.jpg" referrerpolicy="no-referrer"></div></div>然而限于篇幅这里依然没有过多涉及细节，操作系统本身的初始化也是一个比较复杂的过程，感兴趣的同学可以去翻阅相关操作系统的资料。<p></p><p><strong>总结与脑洞</strong></p><p>计算机的启动是一个多阶段的过程，当然在一些嵌入式设备等这个过程会简化，但总体上也需要经过类似过程，只不过阶段数会少一些。</p><p>回到最开始的那个问题，也就是时间有没有开始，其实这个问题一些物理大牛已经回答过了，<strong>但我很想在这里开一个脑洞</strong>，当上帝在为自己创建的宇宙 ( 计算机 ) 加电的那一刻——也就是宇宙大爆炸时，时间开始了，时间这个概念是和宇宙 ( 计算机 ) 相伴相生的，如果没有宇宙 ( 计算机 ) ，时间这个概念其实是没有意义的，就好比如果没有计算机，加载这个概念其实是没有意义的，<strong>你思考时间到底有没有起点这个问题就好比计算机中的程序在思考到底是谁把自己加载到内存的、又是谁把操作系统加载到内存中的等等</strong>。。好啦，脑洞就开到这里。</p><p>想必大家应该明白计算机启动这个问题了吧！</p><div id="recommend_bottom"></div><div id="article_bottom"></div>  
</div>
            