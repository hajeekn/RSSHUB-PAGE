
---
title: 'RISC-V怎样选择高层次综合工具？'
categories: 
 - 新媒体
 - 高科技行业门户
 - 新闻
headimg: 'https://mp.ofweek.com/Upload/News/Img/member39750/202111/wx_article__8284a104d237691e0b0df04adc33a68a.jpg'
author: 高科技行业门户
comments: false
date: Fri, 19 Nov 2021 03:12:00 GMT
thumbnail: 'https://mp.ofweek.com/Upload/News/Img/member39750/202111/wx_article__8284a104d237691e0b0df04adc33a68a.jpg'
---

<div>   
<p style="text-indent: 2em; text-align: left;">文︱BRIAN BAILEY</p><p style="text-indent: 2em; text-align: left;">来源︱Semiconductor Engineering</p><p style="text-indent: 2em; text-align: left;">编译 ｜ 编辑部</p><p style="text-indent: 2em; text-align: left;">高质量的RISC－V实现越来越多，但推动大量设计活动的是架构的可扩展性。挑战在于设计和实现定制处理器，无需每次都在寄存器传输级（RTL）重新实现。</p><p style="text-indent: 2em; text-align: left;">我们需要考虑两种类型的高层次综合（HLS）。第一种是通用HLS，采用C、C＋＋或SystemC中的描述并将其转换为RTL。这些工具能够探索设计空间，并创建最佳架构，这对于面向数据流的算法非常有效。事实上，随着时间的推移，这些工具在处理面向控制的结构方面表现更好。但是，此工具可以用来实现处理器吗？是否还有更好的方法？</p><p style="text-indent: 2em; text-align: left;">另一种类型的HLS是专用于处理器的工具。可扩展处理器并不新鲜。几十年来，Tensilica（Cadence）和ARC（Synopsys）一直使用户能够创建可定制的处理器，而Arm最近也在涉足这一领域。这些工具从专为处理器设计的架构描述语言开始。当前的问题是这两种综合技术能否结合起来。</p><p style="text-indent: 2em; text-align: left;">答案尚不完全清楚。HLS可能并不适用于所有RISC－V设计。“你对标准RISC－V实现感兴趣吗？或者要进行专业化？”Synopsys ASIP工具高级总监Gert Goossens问道。“如果你对标准RISC－V实现感兴趣，那么我不确定HLS会给你带来多大好处，因为你可以在RTL中描述架构并对其进行优化。但是一旦你开始查看指令扩展集，情况就有所不同了。那么问题是哪些扩展最适合我的应用领域，架构探索就变得非常重要了。”</p><p style="text-indent: 2em; text-align: left;">架构优化有不同的级别。“所有HLS工具都能够确保你进行架构探索，” Codasip CTO Zdeněk P?ikryl表示。“通用HLS解决方案非常适合为数据路径和静态调度算法执行此操作，例如图像处理。若设计一个CPU，那就不同了。与在RTL或传统HLS中，我们可以进行更多的探索。在最近的一个例子中，我们从RISC－V基线开始，并使用不同的扩展组合。然后我们探索了自定义扩展并定义了一些新指令。重新运行测试，速度则提高了50倍以上。”</p><p style="text-indent: 2em; text-align: left;">“这是两种技术的融合，有可能对行业产生真正的变革，”Cadence产品管理总监Rob Knoth表示。“处理器设计不仅是最大化GHz。您正在谈论可以针对非常低区域的处理器。有些可能针对极低功耗，有些可能针对传统节点。处理器不是香草，处理器有31种风格，尤其是开始考虑RISC－V时，它是开放和可定制的。特定应用处理器需要可预测的工具，并且需要与物理世界紧密耦合。”</p><p style="text-indent: 2em; text-align: left;">扩展评估是涉及软件的不同级别的架构优化。“您需要为特定目标应用找出‘正确’的自定义指令，以便实现某些目标，无论是内存、功耗、性能还是面积，”西门子业务OneSpin的产品经理Sven Beyer表示。“要做到这一点，需要高级模型，例如带有自定义指令的虚拟原型，运行软件以评估内存使用情况或性能。一旦确定了自定义扩展候选者，就需要在RTL中实施它们，以便对关键绩效指标（KPI）进行最终评估。这个任务在手动编写RTL以及手动编写独立的原型时非常繁琐，即使只是添加到现有的RTL内核。保持模型同步极具挑战性。”</p><p style="text-indent: 2em; text-align: left;"><strong>不仅仅是硬件</strong></p><p style="text-indent: 2em; text-align: left;">处理器介于硬件和软件之间，且相互影响。“当我们审视RISC－V格局、IP格局时，我们看到很多关注点都在硬件上。”Synopsys产品营销经理Patrick Verbist表示。“商业公司和大学提供不同的IP，通常将RTL实现置于公共领域。有一大堆解决方案，每个解决方案都非常关注其RTL实现。他们宣称一个更好，或者有更深的管线，或者更高的性能。但是后来他们说，对于编译方面，需要依赖公共领域的工具。如果想扩展RISC－V怎么办？这些工具是否支持硬件实现？过分关注IP实现的RTL方面。”</p><p style="text-indent: 2em; text-align: left;">有多种设计定制处理器的方法。例如，可以带有附加指令，或者为特定任务附加专用加速器。“HLS确实帮助模糊了处理器内部与处理器外部的界限，例如专用加速器，”Cadence的Knoth表示。“它让这条生产线非常灵活——既适用于特定应用程序，也适用于特定技术。考虑到便携性，如果你有一个面向5nm节点的处理器，它与面向22nm节点的处理器会有非常不同的关注。能够拥有一个一致的SystemC模型，然后为处理器切割某些部分，而将某些部分作为基于硬件的加速器，以获得完整系统的优化实现，这是非常强大的。”</p><p style="text-indent: 2em; text-align: left;">关键是能够优化整个系统，这需要对硬件和软件同时进行分析。“高级架构描述语言，例如CodAL，使我们能够通过指令集以及处理器的微架构来捕获架构。” Codasip的P?ikryl表示。“从单一的描述来看，使用类似于C的语言，我们能够生成基于LLVM的编译器、汇编器、反汇编器、模拟器以及RTL、UVM验证环境和其他输出。”</p><p style="text-indent: 2em; text-align: left;">有多种类型的优化。“从架构的角度开始，在其中定义指令和架构资源列表，”P?ikryl补充道。“我们大致知道想要的时间安排，但并不关注加载／存储单元是使用AHB还是AXI，或者如何处理等待状态。这些是稍后提供的低级细节。一旦对架构感到满意，就可以开始添加微架构信息、低级细节。所有处理器都有很多共同点。需要从内存中获取指令，有危险处理、解码器、加载／存储单元——它们只需要在那里。数据路径可能很简单，只处理整数或浮点数，也可能是SIMD或可扩展向量。”</p><p style="text-align:center"><img width="100%" src="https://mp.ofweek.com/Upload/News/Img/member39750/202111/wx_article__8284a104d237691e0b0df04adc33a68a.jpg" referrerpolicy="no-referrer"></p><p style="text-indent: 2em; text-align: center;">图1：来自CodAL的工具流程。资料来源：Codasip</p><p style="text-indent: 2em; text-align: left;">添加微架构会对其他类型进行优化。“我们定义了两种类型的优化，”Synopsys的Goossens表示。“第一个是循环中的编译器，第二个是循环中的综合。循环中的编译器意味着当您探索指令扩展的不同选择时，您可以为架构的每个实例使用自动生成的编译器。对于每个试验，您生成编译器，然后编译基准代码。该代码在模拟器中运行，您可以分析生成的内容并查看架构中的瓶颈所在。然后你回到处理器模型——在我们的例子中是nML语言——然后你做出改变。”</p><p style="text-align:center"><img width="100%" src="https://mp.ofweek.com/Upload/News/Img/member39750/202111/wx_article__e0e869d4f38bacb24d9d8a49118d5f13.jpg" referrerpolicy="no-referrer"></p><p style="text-indent: 2em; text-align: center;">图2：ASIP 设计师的工具流程。资料来源：新思科技</p><p style="text-indent: 2em; text-align: left;">“第二个是循环中的合成，”Goossens表示。“从相同的处理器模型中，我们生成RTL实现并进行逻辑综合。将生成的Verilog代码进行综合。可以看到设计中的关键路径以及可以实现的时钟频率。然后，可以就处理器的微架构细节做出决定。可以调整管线站的数量。也许数量必须增加，因为有一个关键块，如乘法器，必须成为管线。回到nML模型，那里有描述管线的构造。”</p><p style="text-indent: 2em; text-align: left;">当同时使用处理器扩展和专用加速器时，分区阶段是必要的。“通过在HLS模型上运行模拟以了解整体KPI，可以针对目标应用程序优化微架构参数集和自定义扩展，”OneSpin的Beyer表示。“然后可以使用HLS工具生成RTL，支持内核内部的简单扩展和更高级加速器的松散耦合。因此，使用HLS工具及其对自定义扩展的支持获得精确RTL模型的开销非常低。然后，您可以测量生成的RTL上的KPI，以最终确定扩展和参数的选择。”</p><p style="text-indent: 2em; text-align: left;">商业工具有很多相似之处。“ARC、Tensilica、Codasip和Andes都有描述指令的语言，” Imperas CEO Simon Davidmann表示。“这些语言比RTL稍微抽象一些，其工具可以将语言推入RTL。这些公司还使用LLVM构建了一个工具链。他们通常构建一个模拟器。关键问题之一是必须能够直接用高级语言进行模拟，以便能够进行调试。如果你非得将其翻译成其他语言是没有好处的，因为那样它就会变得更加困难。工具链的另一个重要方面是，当进行小的更改，又不希望更改其下的所有内容时，工程变更单（ECO）的概念很重要。”</p><p style="text-indent: 2em; text-align: left;">语言非常之多</p><p style="text-indent: 2em; text-align: left;">定义新处理器在80年代和90年代风靡一时，但当IP模型开始流行并且少数公司设法凭借高度优化的处理器内核主导市场时，这种定义就不再受欢迎。现在，该定义重返潮流，一些公司采用了过去使用的语言，而另一些公司采用了行业内定义的语言或开发了新的自定义语言。它们都被归类为架构描述语言或ADL。</p><p style="text-indent: 2em; text-align: left;">在最初设计RISC－V时，它使用了一种名为Chisel的新语言。它是一种基于Scala的硬件构造语言，虽然它的抽象级别比RTL稍高，但它不被认为是一种高级综合语言。SiFive使用这种语言来定义其处理器。</p><p style="text-indent: 2em; text-align: left;">纽约哥伦比亚大学的一个研究小组采用了SystemC，并于2020年发表了一篇相关论文。该论文称“HL5是第一个使用SystemC设计并使用商业HLS工具进行优化的32位RISC－V微处理器。我们通过在实验基础设施上执行软件程序来评估HL5，该基础设施将FPGA仿真与用于商用32nm CMOS技术的标准RTL综合流程相结合。”</p><p style="text-indent: 2em; text-align: left;">那么SystemC是最佳选择吗？“SystemC在比RTL更接近概念的更高层次方面具有一些显著的优势，”Knoth认为。“需要与进行算法设计的人保持密切联系，这样他们就可以自由灵活地进行实验和探索他们的想法。那是最好的语言。就使用SystemC进行架构探索和验证的人员而言，其对SystemC进行了大量投资。此外，当通过验证加强生态系统并将其更紧密地连接到实施方面时，它会成为比纯RTL设计更好的价值主张。”</p><p style="text-indent: 2em; text-align: left;">许多硬件／软件工具都被C语言所吸引。“CodAL语言基于C语言，每个人都可以理解，”P?ikryl 表示。“您没有在SystemC或新的编程范式中可以找到的对象或其他东西，工程师更容易采用。SystemC是一个模拟框架，很难捕捉诸如编译器如何利用指令之类的东西。无论如何，你必须有另一个层，所以它不会是纯SystemC。在设计结束时，你最终会得到一种特定领域的语言。”</p><p style="text-indent: 2em; text-align: left;">处理器规范有许多传统语言。“nML是一种用于描述处理器架构和指令集（ISA）的高级定义语言，”Goossens称。相对于SystemC或Chisel等硬件描述语言，nML的优势在于所有软件工具都可以在RTL实现后生成，并且可以保持软件和硬件彼此一致。因此，nML是硬件和软件实现的最佳参考。”</p><p style="text-indent: 2em; text-align: left;">RISC－V社区还需要一种正式的方式来定义处理器。“他们采用了来自英国剑桥大学的SAIL，” Imperas的Davidmann表示。“设计中难以实现的是正确的构造。预先描述一些可以验证的内容，然后将其映射到下一个级别并重新验证。Arm显然拥有从架构到文档的完全自动化。他们有一个流程，从初始表示到文档，再到RTL，再到参考模型，并在此过程中使用正式工具。我们的目标是拥有一种抽象的语言，并以此为流程。”</p><p style="text-indent: 2em; text-align: left;"><strong>验证</strong></p><p style="text-indent: 2em; text-align: left;">随着系统越来越复杂，验证任务往往比设计任务增长得更迅速。这意味着所有可行的解决方案都必须认真对待验证任务。“由于RTL是从HLS模型生成的，因此两者在构造上是同步的，”Beyer表示。“还应该使用HLS模型验证生成的RTL。这与在普通综合工具上通过运行等效性检查所采取的步骤基本相同。自定义扩展的HLS描述还可用于为自定义扩展启用编译器支持、指令集模拟器和工具链的其他元素。”</p><p style="text-indent: 2em; text-align: left;">这依赖于完全验证的高级描述。否则，用户将面临无用输入无用输出的情况。不幸的是，用于执行此操作的工具如今还处于起步阶段。“如果从RISC－V模型开始并进行扩展，仍想要确保基线架构与RISC－V规范完全兼容，”Goossens表示。“因此，我们运行RISC－V验证套件以确保我们的实现真正符合RISC－V规范。”</p><p style="text-indent: 2em; text-align: left;">合规套件不验证微架构，其距离完成还有很长的路要走。“在验证方面没有魔法按钮，”P?ikryl 称。“我们输出一个UVM环境和工具，例如一个随机程序生成器，它知道设计中的每一条指令，包括自定义指令。作为验证工程师，可以获取并使用这些验证工具，或者在此基础上添加更多工具或测试平台。还可以使用生成的TLM SystemC模型进行系统探索并创建虚拟原型。”</p><p style="text-indent: 2em; text-align: left;">这成为更大的“循环”验证的一部分。“我们通常建议嵌入在SystemC中生成的处理器模型，并使用虚拟原型工具，”Goossens表示。“这使用户能够考虑与内存层次结构、内存子系统和测量性能的交互。”</p><p style="text-indent: 2em; text-align: left;">自定义说明意味着用户必须自己进行一些验证。“我们提供带有C级测试程序的基本回归套件，用户可以在处理器架构上编译这些程序，并且可以模拟生成的代码，”Goossens表示。“用户还可以在主机上本地执行这些程序并进行比较。这是从位级别的角度来查看一切是否一致。但是，当添加自定义指令时，需要针对添加的内容使用特定的附加测试程序来扩展此测试套件。”</p><p style="text-indent: 2em; text-align: left;">总结</p><p style="text-indent: 2em; text-align: left;">对于少数企业而言，处理器设计已经成为其核心竞争力，但从处理器内核中获得更高的性能变得越来越困难。为取得重大进展，需要采用多核异构计算解决方案。RISC－V重新唤醒了创造它们的愿望。</p><p style="text-indent: 2em; text-align: left;">该行业正在尝试构建有效的工具链来满足快速发展的市场需求。这个难题覆盖面广泛，而当前产业又面临着碎片化的现状，但无论在优化潜力还是生产力方面，现有工具都比在RTL中编写处理器有着显著提升。</p><p style="text-align:center"><br></p><p style="text-indent: 2em; text-align: left;"><br></p> 
  
</div>
            