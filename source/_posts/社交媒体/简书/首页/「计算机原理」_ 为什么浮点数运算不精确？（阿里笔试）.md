
---
title: '「计算机原理」_ 为什么浮点数运算不精确？（阿里笔试）'
categories: 
 - 社交媒体
 - 简书
 - 首页
headimg: 'https://upload-images.jianshu.io/upload_images/10107787-e69fd9b7e15c793b.png'
author: 简书
comments: false
date: Invalid Date
thumbnail: 'https://upload-images.jianshu.io/upload_images/10107787-e69fd9b7e15c793b.png'
---

<div>   
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="1920" data-height="1080"><img data-original-src="//upload-images.jianshu.io/upload_images/10107787-e69fd9b7e15c793b.png" data-original-width="1920" data-original-height="1080" data-original-format="image/png" data-original-filesize="2244533" src="https://upload-images.jianshu.io/upload_images/10107787-e69fd9b7e15c793b.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
<blockquote>
<p><strong>点赞关注，不再迷路，你的支持对我意义重大！</strong></p>
<p>🔥 <strong>Hi，我是丑丑。本文 <a href="https://www.jianshu.com/writer#/notebooks/49101021/notes/82219290" target="_blank">「计算机组成原理」| 导读 —— </a> 已收录，这里有 Android 进阶成长路线笔记 & 博客，欢迎跟着彭丑丑一起成长。（联系方式在 GitHub）</strong></p>
</blockquote>
<h2>前言</h2>
<p>最近在公众号<code>阿里技术</code>上看到一套孤尽老师出的 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F63TOcAyQL9LIEX9UHLtmyw" target="_blank">10道Java测试题</a>（据说阿里 P7 工程师的答题正确率只有 50%） ，其中有几道题是关于浮点数的，聪明的你，在评论区留下答案吧。</p>
<pre><code>(1)
float a = 0.125f; 
double b = 0.125d;
System.out.println((a - b) == 0.0); 
代码的输出结果是什么？

A. true
B. false
</code></pre>
<pre><code>(2)
double c = 0.8;
double d = 0.7;
double e = 0.6;

那么 c-d 与 d-e 是否相等？

A. true
B. false
</code></pre>
<pre><code>(3)
System.out.println(1.0 / 0); 的结果是什么？

A. 抛出异常
B. Infinity
C. NaN
</code></pre>
<pre><code>(4)
System.out.println(0.0 / 0.0); 的结果是什么？

A. 抛出异常
B. Infinity
C. NaN
D. 1.0
</code></pre>
<pre><code>(5) 引用自《技术之瞳》
以下数字在表示为double(8字节的双精度浮点数)时存在舍入误差的有：

A 100 
B 根号2 
C 10^30
D 0.1 
E 0.5
</code></pre>
<pre><code>(6) 
写出float x 与“零值”比较的if语句
</code></pre>
<hr>
<h2>目录</h2>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="1199" data-height="825"><img data-original-src="//upload-images.jianshu.io/upload_images/10107787-45e1d2b1dde8b1b7.png" data-original-width="1199" data-original-height="825" data-original-format="image/png" data-original-filesize="66430" src="https://upload-images.jianshu.io/upload_images/10107787-45e1d2b1dde8b1b7.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
<hr>
<h2>1. 相关概念</h2>
<p>关于浮点数的相关概念如下，在下面的分享中，我将不重复解释：</p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="1466" data-height="966"><img data-original-src="//upload-images.jianshu.io/upload_images/10107787-e17b272874accc27.png" data-original-width="1466" data-original-height="966" data-original-format="image/png" data-original-filesize="205111" src="https://upload-images.jianshu.io/upload_images/10107787-e17b272874accc27.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
<h2>2. 计算机中数据的表示方法</h2>
<ul>
<li>在你的Chrome浏览器上按<code>F12</code>，然后找到<code>console</code>，输入表达式<code>0.1 + 0.2</code>，回车</li>
<li>在你的电子计算器上按<code>0.1 + 0.2 =</code>
</li>
</ul>
<p>你会发现前者的结果是<code>0.30000000000000004</code>，而后者的结果是<code>0.3</code>（当然了！）。那么，为什么计算机的准确度，连普通的电子计算器的都比不上？关键在于计算机与计算器使用了不同的<strong>数据表示方法</strong>。</p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="1907" data-height="1603"><img data-original-src="//upload-images.jianshu.io/upload_images/10107787-27630f66a634578a.png" data-original-width="1907" data-original-height="1603" data-original-format="image/png" data-original-filesize="215022" src="https://upload-images.jianshu.io/upload_images/10107787-27630f66a634578a.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
<h4>2.1 n 位二进制可以表示的信息量</h4>
<p>对于整数来说，大家都知道8位有符号整数可以表示<code>[-128,127]</code>，8位无符号整数可以表示<code>[0,255]</code>，不管怎么样，8位二进制无论如何也只能表示<code>256个</code>整数。当需要表示<code>257</code>这个数，有且只有两个办法：</p>
<ul>
<li>1、增加位数，例如9位二进制可表示的数值范围就可以容纳<code>257</code>这个数</li>
<li>2、改变编码规则，例如规定真值是在机器数的基础上加一，这样的话，<code>0000,0000</code>就表示数<code>1</code>，<code>1111,1111</code>就表示数257。（事实上，这就是<strong>移码</strong>干的事情，3.1节会再提到）</li>
</ul>
<p>这就是计算机的自有属性，<strong>数字计算机只能处理离散数据，二进制的位数直接决定了它能表示的离散数据个数，也决定了它所能表示的信息个数，对于n位二进制数，它可以表示的信息量为<img class="math-inline" src="https://math.jianshu.com/math?formula=2%5EN" alt="2^N" mathimg="1" referrerpolicy="no-referrer">。</strong></p>
<p>同理，我们把问题域扩展到全体实数，8位二进制同样也只能表示<code>256</code>个实数。假如约定这样一种8位编码：最低两位为小数区域，其余是整数区域，这样就有：</p>
<pre><code>000000.00 // 表示 0.0
000000.01 // 表示 0.25
000000.10 // 表示 0.5
000000.11 // 表示 0.75
000001.00 // 表示 1.0
000001.01 // 表示 1.25
... 此处省略250个数
</code></pre>
<p>我们发现，介于0.0到0.25的数字被跳过了，而即使把小数区域的位长扩大到8位、16位、甚至一个极大的位数，也无法充分表示介于0.0到0.25所有的数。这是因为，在0.0到0.25之间的数是连续的，有无限多个数，但是<strong>有限的N位长二进制最多只能表示<img class="math-inline" src="https://math.jianshu.com/math?formula=2%5EN" alt="2^N" mathimg="1" referrerpolicy="no-referrer">个信息量</strong>，有限的信息量无法表示无限的数据量，这就是现实世界与计算机世界的矛盾。</p>
<h4>2.2 定点数表示</h4>
<p>实数有两种表示格式，分别是<strong>定点数</strong>和<strong>浮点数</strong>。像上面说的这种约定整数部分和小数部分为固定位置的格式，就是定点数表示。</p>
<ul>
<li><p>定义：<br>
<strong>定点数（fixed point numbers）</strong>约定机器数中的小数点总是固定在某个特定的位置。</p></li>
<li><p>格式：<br>
分为符号位、整数部分、隐含的小数点、小数部分。</p></li>
<li><p>特点：<br>
<strong>整数部分和小数部分位长固定，当需要表示绝对值特大或者特小的数需要很大的空间</strong>。</p></li>
</ul>
<h4>2.3 浮点数表示</h4>
<p>我们已经知道32位二进制可以表示的信息量有<img class="math-inline" src="https://math.jianshu.com/math?formula=2%5E%7B32%7D%5Capprox%204*10%5E9" alt="2^&#123;32&#125;\approx 4*10^9" mathimg="1" referrerpolicy="no-referrer">，但是很多语言都会宣称它们的32位单精度浮点数的数值范围约为<img class="math-inline" src="https://math.jianshu.com/math?formula=-3.4*10%5E%7B38%7D%EF%BD%9E%203.4*10%5E%7B38%7D" alt="-3.4*10^&#123;38&#125;～ 3.4*10^&#123;38&#125;" mathimg="1" referrerpolicy="no-referrer">（左右边界），这是因为采用了浮点数格式。</p>
<ul>
<li><p>定义：<br>
<strong>浮点数（floating point numbers）使用科学计数法存储数字</strong>，小数点的位置根据指数的大小而浮动。</p></li>
<li><p>格式：<br>
分为符号位、指数、尾数 ：</p></li>
</ul>
<p><img class="math-block" src="https://math.jianshu.com/math?formula=N%3D2%5EE*M" alt="N=2^E*M" mathimg="1" referrerpolicy="no-referrer"></p>
<ul>
<li><p>特点：<br>
一部分位作为指数，可以扩大所表示的数值范围</p></li>
<li><p>意义：<br>
是数字计算机表示实数的格式，并以<code>IEEE 754 (IEEE Standard for Binary Floating-Point Arithmetic)</code>为标准。</p></li>
</ul>
<h4>2.4 定点数和浮点数的区别</h4>
<ul>
<li>
<code>表示范围</code>：浮点数一部分位为指数，<strong>相同位长，浮点数格式所能表示的数值范围远远大于定点数格式</strong>；</li>
<li>
<code>精度大小</code>：浮点数格式只有一部分位是有效数值位，<strong>相同位长，浮点格式的精度比定点格式低</strong>；</li>
<li>
<code>运算复杂度</code>：浮点数主要包括指数和尾数两部分，运算时需要对阶、尾数计算、规格化等步骤，<strong>浮点运算比定点运算复杂</strong>；</li>
<li>
<code>溢出</code>：定点运算在数超过可表示数值范围即发生溢出；<strong>在浮点运算中，只有规格化后数值超过指数所能表示的范围才溢出。</strong>
</li>
</ul>
<h4>2.5 计算机表示实数的步骤</h4>
<p>前面讲到相关概念时提到了实数的概念，具体如下：</p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="1455" data-height="739"><img data-original-src="//upload-images.jianshu.io/upload_images/10107787-f4f7b5ff1debf42a.png" data-original-width="1455" data-original-height="739" data-original-format="image/png" data-original-filesize="84502" src="https://upload-images.jianshu.io/upload_images/10107787-f4f7b5ff1debf42a.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption">复数的分类 示意图</div>
</div>
<p>一个虚数上相当于两个实数，所以我们只需要关心实数在计算机中的表示即可，将一个实数装载入计算机需要分为三个步骤：</p>
<ul>
<li>
<p>1、转换为二进制数格式<br>
这个步骤可能损失精度，换句话说，有些数会损失精度，而有些数不会，<strong>这取决于表示这个数需要的信息量和浮点数的存储格式</strong></p>
<ul>
<li>
<strong>无理数（无限不循环小数）</strong>包含的信息量是无限的，例如圆周率<img class="math-inline" src="https://math.jianshu.com/math?formula=%5Cpi" alt="\pi" mathimg="1" referrerpolicy="no-referrer">，没有任何一本书能够写到圆周率最后一位，<code>java.lang.Math.PI</code>也只是<img class="math-inline" src="https://math.jianshu.com/math?formula=%5Cpi" alt="\pi" mathimg="1" referrerpolicy="no-referrer">的近似值，类似的，<strong>使用有限的二进制位自然无法精确表示；</strong>
</li>
<li>
<strong>有限循环小数</strong>包含的信息量是有限的，它的信息量分为整数部分+小数不循环部分+小数循环部分，例如<img class="math-inline" src="https://math.jianshu.com/math?formula=1.8333333...%20%3D%201.8%5Coverline%7B3%7D" alt="1.8333333... = 1.8\overline&#123;3&#125;" mathimg="1" referrerpolicy="no-referrer">。但是浮点数的表示方法分为符号位、指数区域和尾数区域，并不会单独用一块区域来存储循环的部分，<strong>因此有限循环小数也无法精确表示；</strong>
</li>
<li>最后剩下<strong>整数和有限小数</strong>，它们包含的信息量也是有限的，<strong>关键看是否有因子5</strong>。举两个例子：0.1和1万亿，请问哪个数能用二进制数精确表示？<br>
从十进制看，0.1拥有2个信息量（个位数为0，第一位小数为1），1万亿拥有一万亿个信息量，二选一的话，肯定是选择信息量更低的0.1。但是，从二进制看，我们会发现0.1转换为二进制居然是一个无限循环小数<img class="math-inline" src="https://math.jianshu.com/math?formula=0.0%5Coverline%7B0011%7D" alt="0.0\overline&#123;0011&#125;" mathimg="1" referrerpolicy="no-referrer">（将整数部分除2取余、小数部分乘2取整来完成转换），所以答案是：1万亿可以精确表示，而0.1无法精确表示！<br>
事实上，在0.1 到 0.9 的 9 个小数中，只有 0.5 可以用二进制精确的表示。怎么理解呢？我们把1想象成一个圆，在十进制里，它可以划分为10等分；但在二进制里，它只能划分为2等分。<br>
也就是说二进制里一位，要么表示0，要么表示一半，它没有办法像十进制那样表示3/10、4/10、6/10...... 1的一半在十进制里是什么？0.5，所以二进制可以精确表示0.5，任何包含因子5的数都可以用二进制精确表示。无法精确表示的数字，存储值只能是真实值的近似表示。</li>
</ul>
<blockquote>
<h6>提示</h6>
<p>类似地，思考下十进制数格式可以精确表示1/3吗？</p>
</blockquote>
</li>
<li><p>2、转换为二进制科学计数法表示<br>
这个步骤将二进制小数转换为规范化的科学计数法表示：<img class="math-inline" src="https://math.jianshu.com/math?formula=N%20%3D%20a%20*%20B%5EE" alt="N = a * B^E" mathimg="1" referrerpolicy="no-referrer">，因为只是写法的转换，所以这一步没有精度损失。</p></li>
<li>
<p>3、转换为IEEE 754 标准格式<br>
IEEE 754严格规定了尾数域和指数域可表示的大小，位数有限，意味着信息量是有限的。有些数需要的二进制数据量巨大，在这个步骤自然会损失精度，具体如下：</p>
<ul>
<li><p>大于浮点数可以表示的最大绝对值：上溢（溢出到<img class="math-inline" src="https://math.jianshu.com/math?formula=%5Cpm%5Cinfty" alt="\pm\infty" mathimg="1" referrerpolicy="no-referrer">）</p></li>
<li><p>小于浮点数可以表示的最小绝对值：下溢（溢出到<img class="math-inline" src="https://math.jianshu.com/math?formula=%5Cpm0" alt="\pm0" mathimg="1" referrerpolicy="no-referrer">）</p></li>
<li><p>尾数有效位数超过尾数域位数（另外还有隐含的整数位1）：舍入误差</p></li>
</ul>
</li>
</ul>
<hr>
<h2>3.  IEEE 754 标准的浮点数</h2>
<p>IEEE 二进制浮点数算术标准（IEEE 754）是广泛使用的浮点数运算标准，是大多数高级语言的现行浮点运算标准，例如C/C++、Java、JavaScript等。</p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="1508" data-height="1226"><img data-original-src="//upload-images.jianshu.io/upload_images/10107787-b2314d4c44669f7a.png" data-original-width="1508" data-original-height="1226" data-original-format="image/png" data-original-filesize="129728" src="https://upload-images.jianshu.io/upload_images/10107787-b2314d4c44669f7a.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
<h4>3.1 一般格式</h4>
<p>浮点数格式的关键是科学计数法格式：<img class="math-inline" src="https://math.jianshu.com/math?formula=N%20%3D%20a%20*%20B%5EE" alt="N = a * B^E" mathimg="1" referrerpolicy="no-referrer">，其中：</p>
<ul>
<li>
<strong>a</strong>称为尾数(mantissa)，或称有效数字(significand)</li>
<li>
<strong>B</strong>称为基数(base)，在二进制数中，基数是2</li>
<li>
<strong>E</strong>称为指数(exponent)</li>
</ul>
<p>一个数的科学计数法表示是不唯一的，举个例子，对于二进制数<img class="math-inline" src="https://math.jianshu.com/math?formula=1111.0000_%7B(2)%7D" alt="1111.0000_&#123;(2)&#125;" mathimg="1" referrerpolicy="no-referrer">来说，以下都是合法的科学计数法表示：<img class="math-inline" src="https://math.jianshu.com/math?formula=111.1*2" alt="111.1*2" mathimg="1" referrerpolicy="no-referrer">、<img class="math-inline" src="https://math.jianshu.com/math?formula=11.11*2%5E2" alt="11.11*2^2" mathimg="1" referrerpolicy="no-referrer">、<img class="math-inline" src="https://math.jianshu.com/math?formula=11110*2%5E%7B-1%7D" alt="11110*2^&#123;-1&#125;" mathimg="1" referrerpolicy="no-referrer">，但这些都不是<strong>规格化</strong>的表示，唯一规格化的表示为：<img class="math-inline" src="https://math.jianshu.com/math?formula=1.111*2%5E3" alt="1.111*2^3" mathimg="1" referrerpolicy="no-referrer">。</p>
<p>对于一个科学计数法表示，当尾数<strong>a</strong>的整数部分有且仅有一位有效数字时，我们称它是规格化的。由于0在数字的最左边是无效的，而在二进制的世界里只有0和1，因此，<strong>二进制数使用规格化的科学计数法时，整数部分固定为1。</strong></p>
<p>既然整数部分1是固定的，那么就没有必要存储整数部分的信息了。正因如此，IEEE 754 标准的浮点数采用隐藏位的策略，<strong>整数部分的1是隐含的</strong>，不需要占用一位比特，这样是使得尾数可以多一位有效数。</p>
<p>综上，IEEE 754 浮点数的一般格式如下：<br>
<img class="math-block" src="https://math.jianshu.com/math?formula=N%20%3D%20(-1)%5Es*1.f*2%5EE" alt="N = (-1)^s*1.f*2^E" mathimg="1" referrerpolicy="no-referrer"></p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="441" data-height="101"><img data-original-src="//upload-images.jianshu.io/upload_images/10107787-d8691834f9d0f72c.png" data-original-width="441" data-original-height="101" data-original-format="image/png" data-original-filesize="7567" src="https://upload-images.jianshu.io/upload_images/10107787-d8691834f9d0f72c.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption">IEEE 754 标准的一般格式</div>
</div>
<p>现在，我们已经知道浮点数划分的三个区域，现在我们来看这三个区域是如何求值的：</p>
<ul>
<li><strong>符号位：0表示正，1表示负</strong></li>
<li>
<strong>指数区域：移码</strong>
<ul>
<li>指数区域采用移码表示：<img class="math-inline" src="https://math.jianshu.com/math?formula=E%20%3D%20%E6%9C%BA%E5%99%A8%E6%95%B0%20-%20bias" alt="E = 机器数 - bias" mathimg="1" referrerpolicy="no-referrer">，偏移值<img class="math-inline" src="https://math.jianshu.com/math?formula=bias%3D2%5E%7B%E4%BD%8D%E9%95%BF-1%7D-1" alt="bias=2^&#123;位长-1&#125;-1" mathimg="1" referrerpolicy="no-referrer"><br>
例如位长为8时，<img class="math-inline" src="https://math.jianshu.com/math?formula=bias%3D127" alt="bias=127" mathimg="1" referrerpolicy="no-referrer">，位长为11时，<img class="math-inline" src="https://math.jianshu.com/math?formula=bias%3D1023" alt="bias=1023" mathimg="1" referrerpolicy="no-referrer">
</li>
<li>注意：指数域全0和全1为特殊值</li>
</ul>
</li>
<li>
<strong>尾数区域：隐藏整数位的原码</strong><br>
尾数区域采用原码表示：<img class="math-inline" src="https://math.jianshu.com/math?formula=1.f%20%3D%201%20%2B%20%E6%9C%BA%E5%99%A8%E6%95%B0" alt="1.f = 1 + 机器数" mathimg="1" referrerpolicy="no-referrer">
</li>
</ul>
<p>举个例子，十进制数<img class="math-inline" src="https://math.jianshu.com/math?formula=100_%7B(10)%7D" alt="100_&#123;(10)&#125;" mathimg="1" referrerpolicy="no-referrer">转换为二进制为<img class="math-inline" src="https://math.jianshu.com/math?formula=1.100100*2%5E6_%7B(2)%7D" alt="1.100100*2^6_&#123;(2)&#125;" mathimg="1" referrerpolicy="no-referrer">。这里推荐一个站点：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.h-schmidt.net%2FFloatConverter%2FIEEE754.html" target="_blank">浮点数转换器</a>，它可以很方便地对比实数的真值与机器数表示，如下图所示：</p>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="1948" data-height="486"><img data-original-src="//upload-images.jianshu.io/upload_images/10107787-46d6864eab46763e.png" data-original-width="1948" data-original-height="486" data-original-format="image/png" data-original-filesize="84898" src="https://upload-images.jianshu.io/upload_images/10107787-46d6864eab46763e.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
<h4>3.2 两种常用格式</h4>
<p>前面讲的是IEEE 754 浮点数的一般格式，其中最常用的是<code>32位单精度浮点数</code>和<code>64位双精度浮点数</code>，在高级语言中通常代表<code>float</code>和<code>double</code>两种数据类型（例如C/C++、Java）,在有些语言中只有一种数字格式<code>number</code>（例如JavaScript/TypeScript）。</p>
<ul>
<li>
<strong>单精度</strong><br>
单精度浮点数有<strong>8位指数，23位尾数</strong>，再加上隐藏的整数1，总共有24位二进制精度</li>
<li>
<strong>双精度</strong><br>
双精度浮点数有<strong>11位指数，52位尾数</strong>，再加上隐藏的整数1，总共有53位二进制精度，具体如下：</li>
</ul>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="1320" data-height="652"><img data-original-src="//upload-images.jianshu.io/upload_images/10107787-c73395fb935c81a6.png" data-original-width="1320" data-original-height="652" data-original-format="image/png" data-original-filesize="101363" src="https://upload-images.jianshu.io/upload_images/10107787-c73395fb935c81a6.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
<h4>3.3 特殊值</h4>
<p>在 IEEE 754 标准规定指数区域全0 或 全1为特殊值，具体如下：</p>
<ul>
<li>
<p><code>非规范化数（Denormalized Number）</code></p>
<ul>
<li>定义：指数域全0，尾数域不为0（去掉隐含整数域为1的约定）</li>
<li>意义：可以保存绝对值更小的数，所有可表示的浮点数的差值都可以表示</li>
</ul>
</li>
<li>
<p><code>+0/-0</code></p>
<ul>
<li>定义：指数域全0，尾数域全0（去掉隐含整数域为1的约定）。IEEE 754 未要求具体的尾数域，意味着NaN不是一个而是一族。</li>
<li>意义：符号位为0是+0，符号位为1是-0，在涉及无穷的运算中避免丢失符号信息，例如<img class="math-inline" src="https://math.jianshu.com/math?formula=%5Cfrac%7B1%7D%7B1%2Fx%7D%20%3D%20x" alt="\frac&#123;1&#125;&#123;1/x&#125; = x" mathimg="1" referrerpolicy="no-referrer">，如果0不区分正负，在<img class="math-inline" src="https://math.jianshu.com/math?formula=x%3D%5Cpm%5Cinfty" alt="x=\pm\infty" mathimg="1" referrerpolicy="no-referrer">时不成立</li>
</ul>
</li>
<li>
<p><code>正负无穷（Infinity）</code></p>
<ul>
<li>定义：指数域全1，尾数全0</li>
<li>意义：用于表达计算中产生的上溢（overflow），使得计算中出现上溢不至于终止计算</li>
<li>产生：除了NaN外的非零值除以0，其结果为正负无穷</li>
</ul>
</li>
<li>
<p><code>NaN（Not a Number）</code></p>
<ul>
<li>定义：指数域全1，尾数域不为0</li>
<li>意义：表示计算中的错误情况，例如<img class="math-inline" src="https://math.jianshu.com/math?formula=%5Cfrac%7B0.0%7D%7B0.0%7D" alt="\frac&#123;0.0&#125;&#123;0.0&#125;" mathimg="1" referrerpolicy="no-referrer">、<img class="math-inline" src="https://math.jianshu.com/math?formula=%5Csqrt2" alt="\sqrt2" mathimg="1" referrerpolicy="no-referrer">，使得计算中出现错误不至于终止计算</li>
<li>特点：<code>NaN</code>是无序的，比较操作符在任一操作数为<code>NaN</code>是为<code>false</code>，<code>!=</code>在任一操作数为<code>NaN</code>时为true，这意味着<code>NaN != NaN</code>。</li>
</ul>
</li>
</ul>
<hr>
<h4>参考资料</h4>
<ul>
<li>《编码·隐匿在计算机软硬件背后的语言》(第23章) —— [美] Charles Petzold 著</li>
<li>《Java编程思想》(第2章) —— [美] Bruce Eckel 著</li>
<li>《深入理解Java虚拟机》(第6.4节) —— 周志明 著</li>
<li>《JavaScript权威指南》(第3章) —— [美] David Flanagan 著</li>
<li>《计算机组成原理考研复习指导》(第2章) —— 王道论坛 组编</li>
<li>
<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjustjavac.com%2Fcodepuzzle.html" target="_blank">《代码之谜》</a> (第4、5章)—— justjavac(迷渡)的博客文章</li>
</ul>
<hr>
<blockquote>
<p><strong>创作不易，你的「三连」是丑丑最大的动力，我们下次见！</strong></p>
</blockquote>
<div class="image-package">
<div class="image-container">
<div class="image-container-fill"></div>
<div class="image-view" data-width="1120" data-height="630"><img data-original-src="//upload-images.jianshu.io/upload_images/10107787-8a6d3a74f22bec02.png" data-original-width="1120" data-original-height="630" data-original-format="image/png" data-original-filesize="1335756" src="https://upload-images.jianshu.io/upload_images/10107787-8a6d3a74f22bec02.png" referrerpolicy="no-referrer"></div>
</div>
<div class="image-caption"></div>
</div>
  
</div>
            