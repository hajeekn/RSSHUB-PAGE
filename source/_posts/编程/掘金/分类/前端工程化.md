
---
title: '前端工程化'
categories: 
 - 编程
 - 掘金
 - 分类
headimg: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59f9aeb44124b7e81a3346c5c2b2fd8~tplv-k3u1fbpfcp-watermark.image'
author: 掘金
comments: false
date: Tue, 13 Jul 2021 05:44:29 GMT
thumbnail: 'https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59f9aeb44124b7e81a3346c5c2b2fd8~tplv-k3u1fbpfcp-watermark.image'
---

<div>   
<div class="markdown-body"><style>.markdown-body&#123;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333&#125;.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6&#123;line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px&#125;.markdown-body h1&#123;font-size:30px;margin-bottom:5px&#125;.markdown-body h2&#123;padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec&#125;.markdown-body h3&#123;font-size:18px;padding-bottom:0&#125;.markdown-body h4&#123;font-size:16px&#125;.markdown-body h5&#123;font-size:15px&#125;.markdown-body h6&#123;margin-top:5px&#125;.markdown-body p&#123;line-height:inherit;margin-top:22px;margin-bottom:22px&#125;.markdown-body img&#123;max-width:100%&#125;.markdown-body hr&#123;border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px&#125;.markdown-body code&#123;word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em&#125;.markdown-body code,.markdown-body pre&#123;font-family:Menlo,Monaco,Consolas,Courier New,monospace&#125;.markdown-body pre&#123;overflow:auto;position:relative;line-height:1.75&#125;.markdown-body pre>code&#123;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8&#125;.markdown-body a&#123;text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff&#125;.markdown-body a:active,.markdown-body a:hover&#123;color:#275b8c&#125;.markdown-body table&#123;display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6&#125;.markdown-body thead&#123;background:#f6f6f6;color:#000;text-align:left&#125;.markdown-body tr:nth-child(2n)&#123;background-color:#fcfcfc&#125;.markdown-body td,.markdown-body th&#123;padding:12px 7px;line-height:24px&#125;.markdown-body td&#123;min-width:120px&#125;.markdown-body blockquote&#123;color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8&#125;.markdown-body blockquote:after&#123;display:block;content:""&#125;.markdown-body blockquote>p&#123;margin:10px 0&#125;.markdown-body ol,.markdown-body ul&#123;padding-left:28px&#125;.markdown-body ol li,.markdown-body ul li&#123;margin-bottom:0;list-style:inherit&#125;.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item&#123;list-style:none&#125;.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul&#123;margin-top:0&#125;.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul&#123;margin-top:3px&#125;.markdown-body ol li&#123;padding-left:6px&#125;.markdown-body .contains-task-list&#123;padding-left:0&#125;.markdown-body .task-list-item&#123;list-style:none&#125;@media (max-width:720px)&#123;.markdown-body h1&#123;font-size:24px&#125;.markdown-body h2&#123;font-size:20px&#125;.markdown-body h3&#123;font-size:18px&#125;&#125;</style><h1 data-id="heading-0">工程化</h1>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59f9aeb44124b7e81a3346c5c2b2fd8~tplv-k3u1fbpfcp-watermark.image" alt="无标题.png" loading="lazy" referrerpolicy="no-referrer"></p>
<h2 data-id="heading-1">定义</h2>
<p>前端工程化是指遵循一定标准和规范，通过工具去提高效率、降低成本的手段。</p>
<blockquote>
<p>一切以提高效率、降低成本、质量保证为目的的手段都属于工程化</p>
</blockquote>
<h2 data-id="heading-2">主要解决的问题</h2>
<ul>
<li>传统语言或者语法的弊端</li>
<li>无法使用模块化/组件化</li>
<li>重复的机械式工作</li>
<li>代码风格统一、质量保证</li>
<li>依赖后端服务接口支持</li>
<li>整体依赖后端项目</li>
</ul>
<h2 data-id="heading-3">工程化≠某个工具</h2>
<p>在现阶段有一部分工具过于庞大，例如webpack，导致有些新手就误认为工程化就是指webpack，只要用了webpack就有了工程化，其实不是这样的。工具并不是工程化的核心，工程化的核心是对项目整体的规划或者架构，工具在这个过程中只是用来落地去实现这种规划或架构的一种手段。</p>
<h1 data-id="heading-4">脚手架工具</h1>
<h2 data-id="heading-5">脚手架工具概要</h2>
<p>脚手架的本质作用是创建项目基础结构，提供项目规范和约定。</p>
<blockquote>
<p><strong>相同的约定：</strong></p>
<ul>
<li>相同的组织结构</li>
<li>相同的开发范式</li>
<li>相同的模块依赖</li>
<li>相同的工具配置</li>
<li>相同的基础代码</li>
</ul>
</blockquote>
<h2 data-id="heading-6">常用的脚手架工具</h2>
<p>react项目-->create-react-app、vue项目-->vue-cli、angular项目-->angular-cli，
以上三种脚手架都是根据信息创建对应的项目基础结构。<br>
Yeoman是通用型项目脚手架工具，它可以根据一套模板生成对应的项目结构，这种比较灵活，容易扩展。<br>
Plop用于在项目开发过程中创建特定类型的文件，例如创建一个组件/模块所需要的文件。</p>
<h3 data-id="heading-7">Yeoman</h3>
<h4 data-id="heading-8">基本使用</h4>
<p><strong>安装</strong><br>
全局范围安装yo<code>npm i yo --global</code><br>
安装对应的generator，这里用node作示例<code>npm i generator-node --global</code><br>
通过yo运行generator<code>yo node</code><br>
<strong>sub generator</strong><br>
在已有的项目基础上创建特定类型的文件，例如<code>yo node:cli</code></p>
<p><strong>使用步骤总结</strong></p>
<ol>
<li>明确你的需求</li>
<li>找到合适的Generator</li>
<li>全局范围安装找到的Generator</li>
<li>通过yo运行对应的Generator</li>
<li>通过命令行交互填写选项</li>
<li>生成你所需要的项目结构</li>
</ol>
<h4 data-id="heading-9">自定义Generator</h4>
<p>自定义Generator就是基于Yeoman搭建自己的脚手架。<br>
<strong>创建Generator</strong></p>
<blockquote>
<p>Generator本质上就是一个npm模块</p>
</blockquote>
<p>Generator基本结构</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71c51144012e46b291e1e5344a8944d4~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer">
命令<br>
<code>generator-<name></code></p>
<p><strong>示例</strong></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//创建generator-sample目录</span>
mkdir generator-sample
cd generator-sample\
<span class="hljs-comment">//初始化package.json</span>
npm init
<span class="hljs-comment">//安装yeoman依赖</span>
npm i yeoman-generator
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接着进入generator-sample文件夹创建generators/app/index.js文件</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// index.js</span>
<span class="hljs-comment">// 此文件作为 Generator 的核心入口</span>
<span class="hljs-comment">// 需要导出一个继承自 Yeoman Generator 的类型</span>
<span class="hljs-comment">// Yeoman Generator 在工作时会自动调用我们在此类型中定义的一些生命周期方法</span>
<span class="hljs-comment">// 我们在这些方法中可以通过调用父类提供的一些工具方法实现一些功能，例如文件写入</span>

<span class="hljs-keyword">const</span> Generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">'yeoman-generator'</span>)
<span class="hljs-comment">//导出一个类型，让这个类型继承自Generator</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Generator</span> </span>&#123;
  writing () &#123;
    <span class="hljs-comment">// Yeoman 自动在生成文件阶段调用此方法</span>
    <span class="hljs-comment">// 我们这里尝试往项目目录中写入文件</span>
    <span class="hljs-built_in">this</span>.fs.write(
        <span class="hljs-comment">//文件绝对路径</span>
        <span class="hljs-built_in">this</span>.destinationPath(<span class="hljs-string">'temp.txt'</span>),
        <span class="hljs-built_in">Math</span>.random().toString()
    )
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>接着通过<code>npm link</code>方式链接到全局范围，使之成为全局模块包，这样yeoman在工作的时候就可以找到我们写的generator-sample。然后就可以通过<code>yo sample</code>运行这个生成器创建一个temp.txt。</p>
<ul>
<li><strong>根据模板创建文件</strong></li>
</ul>
<p>很多时候需要自动创建的文件很多，而且文件的内容也相对复杂，这种情况下可以使用模板创建文件。
首先创建generators/app/templates/foo.txt文件</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 这是一个模板文件foo.txt</span>
<span class="hljs-comment">// 内部可以使用 EJS 模板标记输出数据</span>
<span class="hljs-comment">// 例如：<%= title %></span>
<span class="hljs-comment">// 其他的 EJS 语法也支持</span>

<% <span class="hljs-keyword">if</span> (success) &#123; %>
哈哈哈
<% &#125;%>
<span class="copy-code-btn">复制代码</span></code></pre>
<p>有了模板过后，在生成文件时就可以通过模板方式写入文件到目标目录</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// index.js</span>
<span class="hljs-comment">// 此文件作为 Generator 的核心入口</span>
<span class="hljs-comment">// 需要导出一个继承自 Yeoman Generator 的类型</span>
<span class="hljs-comment">// Yeoman Generator 在工作时会自动调用我们在此类型中定义的一些生命周期方法</span>
<span class="hljs-comment">// 我们在这些方法中可以通过调用父类提供的一些工具方法实现一些功能，例如文件写入</span>

<span class="hljs-keyword">const</span> Generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">'yeoman-generator'</span>)

<span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Generator</span> </span>&#123;
  writing () &#123;
    <span class="hljs-comment">// Yeoman 自动在生成文件阶段调用此方法</span>

    <span class="hljs-comment">// 通过模板方式写入文件到目标目录</span>
    <span class="hljs-comment">// 模板文件路径</span>
    <span class="hljs-keyword">const</span> tmpl = <span class="hljs-built_in">this</span>.templatePath(<span class="hljs-string">'foo.txt'</span>)
    <span class="hljs-comment">// 输出目标路径</span>
    <span class="hljs-keyword">const</span> output = <span class="hljs-built_in">this</span>.destinationPath(<span class="hljs-string">'foo.txt'</span>)
    <span class="hljs-comment">// 模板数据上下文</span>
    <span class="hljs-keyword">const</span> context = &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">'Hello zce~'</span>, <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span> &#125;
    <span class="hljs-comment">// 自动把模板文件映射到输出目录上</span>
    <span class="hljs-built_in">this</span>.fs.copyTpl(tmpl, output, context)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<ul>
<li><strong>接收用户输入数据</strong></li>
</ul>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// index.js</span>
<span class="hljs-comment">// 此文件作为 Generator 的核心入口</span>
<span class="hljs-comment">// 需要导出一个继承自 Yeoman Generator 的类型</span>
<span class="hljs-comment">// Yeoman Generator 在工作时会自动调用我们在此类型中定义的一些生命周期方法</span>
<span class="hljs-comment">// 我们在这些方法中可以通过调用父类提供的一些工具方法实现一些功能，例如文件写入</span>

<span class="hljs-keyword">const</span> Generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">'yeoman-generator'</span>)

<span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Generator</span> </span>&#123;
  prompting () &#123;
    <span class="hljs-comment">// Yeoman 在询问用户环节会自动调用此方法</span>
    <span class="hljs-comment">// 在此方法中可以调用父类的 prompt() 方法发出对用户的命令行询问</span>
    <span class="hljs-comment">// 返回的是一个promise</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.prompt([
      &#123;
        <span class="hljs-attr">type</span>: <span class="hljs-string">'input'</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">'name'</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">'Your project name'</span>,
        <span class="hljs-attr">default</span>: <span class="hljs-built_in">this</span>.appname <span class="hljs-comment">// appname 为项目生成目录名称</span>
      &#125;
    ])
    .then(<span class="hljs-function"><span class="hljs-params">answers</span> =></span> &#123;
      <span class="hljs-built_in">this</span>.answers = answers
    &#125;)
  &#125;
  writing () &#123;
    <span class="hljs-comment">// Yeoman 自动在生成文件阶段调用此方法</span>

    <span class="hljs-comment">// 模板文件路径</span>
    <span class="hljs-keyword">const</span> tmpl = <span class="hljs-built_in">this</span>.templatePath(<span class="hljs-string">'bar.html'</span>)
    <span class="hljs-comment">// 输出目标路径</span>
    <span class="hljs-keyword">const</span> output = <span class="hljs-built_in">this</span>.destinationPath(<span class="hljs-string">'bar.html'</span>)
    <span class="hljs-comment">// 模板数据上下文</span>
    <span class="hljs-keyword">const</span> context = <span class="hljs-built_in">this</span>.answers

    <span class="hljs-built_in">this</span>.fs.copyTpl(tmpl, output, context)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<h4 data-id="heading-10">Vue Generator案例</h4>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">//创建目录</span>
mkdir generator-jc-vue
cd generator-jc-vue\
<span class="hljs-comment">//初始化package.json</span>
npm init
<span class="hljs-comment">//安装yeoman依赖</span>
npm i yeoman-generator
<span class="copy-code-btn">复制代码</span></code></pre>
<p>新建generator主目录文件generators/app/index.js<br>
创建generators/app/templates目录，把项目原有的结构拷贝进来作为模板，并将相应的项目名称改写成模板引擎语法<code><%= name %></code>
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ef26eac8cd644ef8f2a45ab46fbb58d~tplv-k3u1fbpfcp-watermark.image" alt="image.png" loading="lazy" referrerpolicy="no-referrer"></p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">const</span> Generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">'yeoman-generator'</span>)

<span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Generator</span> </span>&#123;
  prompting () &#123;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.prompt([
      &#123;
        <span class="hljs-attr">type</span>: <span class="hljs-string">'input'</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">'name'</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">'Your project name'</span>,
        <span class="hljs-attr">default</span>: <span class="hljs-built_in">this</span>.appname
      &#125;
    ])
    .then(<span class="hljs-function"><span class="hljs-params">answers</span> =></span> &#123;
      <span class="hljs-built_in">this</span>.answers = answers
    &#125;)
  &#125;

  writing () &#123;
    <span class="hljs-comment">// 把每一个文件都通过模板转换到目标路径</span>

    <span class="hljs-keyword">const</span> templates = [
      <span class="hljs-string">'.browserslistrc'</span>,
      <span class="hljs-string">'.editorconfig'</span>,
      <span class="hljs-string">'.env.development'</span>,
      <span class="hljs-string">'.env.production'</span>,
      <span class="hljs-string">'.eslintrc.js'</span>,
      <span class="hljs-string">'.gitignore'</span>,
      <span class="hljs-string">'babel.config.js'</span>,
      <span class="hljs-string">'package.json'</span>,
      <span class="hljs-string">'postcss.config.js'</span>,
      <span class="hljs-string">'README.md'</span>,
      <span class="hljs-string">'public/favicon.ico'</span>,
      <span class="hljs-string">'public/index.html'</span>,
      <span class="hljs-string">'src/App.vue'</span>,
      <span class="hljs-string">'src/main.js'</span>,
      <span class="hljs-string">'src/router.js'</span>,
      <span class="hljs-string">'src/assets/logo.png'</span>,
      <span class="hljs-string">'src/components/HelloWorld.vue'</span>,
      <span class="hljs-string">'src/store/actions.js'</span>,
      <span class="hljs-string">'src/store/getters.js'</span>,
      <span class="hljs-string">'src/store/index.js'</span>,
      <span class="hljs-string">'src/store/mutations.js'</span>,
      <span class="hljs-string">'src/store/state.js'</span>,
      <span class="hljs-string">'src/utils/request.js'</span>,
      <span class="hljs-string">'src/views/About.vue'</span>,
      <span class="hljs-string">'src/views/Home.vue'</span>
    ]
    <span class="hljs-comment">// 循环遍历生成对应的目标文件</span>
    templates.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =></span> &#123;
      <span class="hljs-comment">// item => 每个文件路径</span>
      <span class="hljs-built_in">this</span>.fs.copyTpl(
        <span class="hljs-built_in">this</span>.templatePath(item),
        <span class="hljs-built_in">this</span>.destinationPath(item),
        <span class="hljs-built_in">this</span>.answers
      )
    &#125;)
  &#125;
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<p>通过<code>yo jc-vue</code>命令生成项目</p>
<h4 data-id="heading-11">发布Generator</h4>
<p>因为Generator实际上就是一个npm模块，所以发布Generator就是发布一个npm模块，我们只需要将自己写好的Generator模块通过<code>npm publish</code>命令发布成一个公开的模块。</p>
<h3 data-id="heading-12">Plop</h3>
<p>Plop是一个主要去创建项目中特定类型文件的工具，一般会集成到项目中用来自动化的创建同类型的文件，不独立使用。</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 安装依赖</span>
npm i plop --dev
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在项目根目录下新建一个plopfile.js文件</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// Plop 入口文件，需要导出一个函数</span>
<span class="hljs-comment">// 此函数接收一个 plop 对象，用于创建生成器任务</span>

<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">plop</span> =></span> &#123;
  <span class="hljs-comment">// setGenerator(生成器名字,生成器配置选项)</span>
  plop.setGenerator(<span class="hljs-string">'component'</span>, &#123;
    <span class="hljs-comment">// 生成器描述</span>
    <span class="hljs-attr">description</span>: <span class="hljs-string">'create a component'</span>,
    <span class="hljs-comment">// 命令行问题</span>
    <span class="hljs-attr">prompts</span>: [
      &#123;
        <span class="hljs-attr">type</span>: <span class="hljs-string">'input'</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">'name'</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">'component name'</span>,
        <span class="hljs-attr">default</span>: <span class="hljs-string">'MyComponent'</span>
      &#125;
    ],
    <span class="hljs-comment">// 生成器在完成命令行问题后执行的动作</span>
    <span class="hljs-attr">actions</span>: [
      &#123;
        <span class="hljs-attr">type</span>: <span class="hljs-string">'add'</span>, <span class="hljs-comment">// 代表添加文件</span>
        <span class="hljs-attr">path</span>: <span class="hljs-string">'src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.js'</span>,
        <span class="hljs-attr">templateFile</span>: <span class="hljs-string">'plop-templates/component.hbs'</span> <span class="hljs-comment">// 模板文件</span>
      &#125;,
      &#123;
        <span class="hljs-attr">type</span>: <span class="hljs-string">'add'</span>, <span class="hljs-comment">// 代表添加文件</span>
        <span class="hljs-attr">path</span>: <span class="hljs-string">'src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.css'</span>,
        <span class="hljs-attr">templateFile</span>: <span class="hljs-string">'plop-templates/component.css.hbs'</span>
      &#125;,
      &#123;
        <span class="hljs-attr">type</span>: <span class="hljs-string">'add'</span>, <span class="hljs-comment">// 代表添加文件</span>
        <span class="hljs-attr">path</span>: <span class="hljs-string">'src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.test.js'</span>,
        <span class="hljs-attr">templateFile</span>: <span class="hljs-string">'plop-templates/component.test.hbs'</span>
      &#125;
    ]
  &#125;)
&#125;
<span class="copy-code-btn">复制代码</span></code></pre>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// 执行plop</span>
npm plop component
<span class="copy-code-btn">复制代码</span></code></pre>
<h2 data-id="heading-13">脚手架的工作原理</h2>
<p>大部分脚手架的工作原理就是启动之后去询问你一些预设的问题，根据你的回答结合模板文件生成一个项目的结构。</p>
<pre><code class="hljs language-js copyable" lang="js">mkdir sample-scaffolding
cd sample-scaffolding\
npm init
<span class="copy-code-btn">复制代码</span></code></pre>
<p>在package.json文件中添加bin字段，用于指定cli项目的入口文件</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-comment">// package.json</span>
&#123;
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"sample-scaffolding"</span>,
  <span class="hljs-string">"version"</span>: <span class="hljs-string">"0.1.0"</span>,
  <span class="hljs-string">"main"</span>: <span class="hljs-string">"index.js"</span>,
  <span class="hljs-string">"bin"</span>: <span class="hljs-string">"cli.js"</span>,
  <span class="hljs-string">"author"</span>: <span class="hljs-string">"zce <w@zce.me> (https://zce.me)"</span>,
  <span class="hljs-string">"license"</span>: <span class="hljs-string">"MIT"</span>,
  <span class="hljs-string">"dependencies"</span>: &#123;
    <span class="hljs-string">"ejs"</span>: <span class="hljs-string">"^2.6.2"</span>,
    <span class="hljs-string">"inquirer"</span>: <span class="hljs-string">"^7.0.0"</span>
  &#125;
&#125;

<span class="copy-code-btn">复制代码</span></code></pre>
<p>添加cli.js文件</p>
<pre><code class="hljs language-js copyable" lang="js"><span class="hljs-meta">#!/usr/bin/env node</span>
<span class="hljs-comment">// Node CLI 应用入口文件必须要有这样的文件头</span>
<span class="hljs-comment">// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755，这样这个文件才可以作为一个cli入口</span>
<span class="hljs-comment">// 具体就是通过 chmod 755 cli.js 实现修改</span>

<span class="hljs-comment">// 脚手架的工作过程：</span>
<span class="hljs-comment">// 1. 通过命令行交互询问用户问题</span>
<span class="hljs-comment">// 2. 根据用户回答的结果生成文件</span>

<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>)
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)
<span class="hljs-keyword">const</span> inquirer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'inquirer'</span>)
<span class="hljs-keyword">const</span> ejs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ejs'</span>)

inquirer.prompt([
  &#123;
    <span class="hljs-attr">type</span>: <span class="hljs-string">'input'</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'name'</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">'Project name?'</span>
  &#125;
])
.then(<span class="hljs-function"><span class="hljs-params">anwsers</span> =></span> &#123;
  <span class="hljs-comment">// 根据用户回答的结果生成文件</span>

  <span class="hljs-comment">// 模板目录</span>
  <span class="hljs-keyword">const</span> tmplDir = path.join(__dirname, <span class="hljs-string">'templates'</span>)
  <span class="hljs-comment">// 目标目录</span>
  <span class="hljs-keyword">const</span> destDir = process.cwd()

  <span class="hljs-comment">// 将模板下的文件全部转换到目标目录</span>
  fs.readdir(tmplDir, <span class="hljs-function">(<span class="hljs-params">err, files</span>) =></span> &#123;
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err
    files.forEach(<span class="hljs-function"><span class="hljs-params">file</span> =></span> &#123;
      <span class="hljs-comment">// 通过模板引擎渲染文件</span>
      ejs.renderFile(path.join(tmplDir, file), anwsers, <span class="hljs-function">(<span class="hljs-params">err, result</span>) =></span> &#123;
        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err

        <span class="hljs-comment">// 将结果写入目标文件路径</span>
        fs.writeFileSync(path.join(destDir, file), result)
      &#125;)
    &#125;)
  &#125;)
&#125;)
<span class="copy-code-btn">复制代码</span></code></pre>
<p>执行<code>npm link</code>把这个模块link到全局
执行<code>sample-scaffolding</code>生成文件</p></div>  
</div>
            